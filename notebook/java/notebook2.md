# Java核心技术 笔记2

## 继承

### 类、超类和子类

Java使用`extends`定义继承

* 已存在的类称为超类(superclass)、基类（base class) 或父类（parent class)
* 新类称为子类（subclass)、 派生类( derived class) 或孩子类（ child class )

子类可以通过重写覆盖超类中的方法，子类想要使用父类同名方法 `super.method()`，`super`是指示编译器调用超类方法的特殊关键字

* 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism)
* 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding)

#### 理解方法调用

以`x.f(args)`为例,隐式参数x声明为类`C`的一个对象,具体步骤如下:

1. 编译器査看对象的声明类型和方法名(`f`可能被重载)，列举所有`C`类中名为`f`的方法和超类中`public`的`f`的方法

2. 编译器将査看调用方法时提供的参数类型,存在一个与提供的参数类型完全匹配的方法，则选择这个方法，这个过程称之为重栽解析（overloading resolution)。**编译器已获得需要调用的方法名字和参数类型**

3. 如果**编译器**知道调用哪个方法，就称之为**静态绑定**（static binding)

4. 如果编译器不知道，调用的方法依赖于隐式参数的实际类型,则称之为**动态绑定**

5. 采用动态绑定调用方法时，虚拟机一定调用`x`所引用对象的实际类型最合适的那个类的方法。假设`x`实际类型为`D`,为`C`的超类，则会先看`D`是否有该方法，没有则在超类中寻找

虚拟机预先为每个类创建了一个方法表（method table), 其中列出了所有方法的签名和实际调用的方法，以便在真正调用的时候查表

#### 阻止继承：`final` 类和方法

* `final`修饰的类可以阻止被继承
* `final`修饰的方法阻止被子类`override`，确保它们不会在子类中改变语义

#### 强制类型转换

* 可以在继承层次内进行类型转换

* 超类转换成子类之前，应使用`instanceof`进行检查

#### 抽象类

包含一个或多个抽象方法的类本身必须被声明为抽象类

>`abstract`修饰的方法为抽象方法，不需要实现

* 抽象类还可以包含具体数据和具体方法
* 类即使不含抽象方法，也可以将类声明为抽象类
* 抽象类不能被实例化
* 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象

#### 受保护访问

允许被子类访问的方法或域可以声明为`protected`
