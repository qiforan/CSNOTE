# C++ Primer 笔记

## 函数

### 数组作为参数

数组有两个特殊的性质：

1. 不允许拷贝数组
2. 数组使用时会将其转换为指针


当我们为一个函数传递数组时，实际上传递的是指向数组首元素的指针。

```c++
void print(const int*)
void print(const int[]);
void print(const int[10]);
```

这三个函数是等价的：形参都是 `const int *`。

#### 常见传递数组参数有三种方式：

##### 使用标记指定数组长度

典型代表是 C 风格字符串。

##### 使用标准库规范

传递指向数组 **首元素** 和 **尾后元素** 的指针。

##### 显式传递一个表示数组大小的形参

#### 数组形参与 `const`

为数组参数添加 `const` 后不能在函数里修改数组元素值

```c++
void fun(const int * a)
{
	a[0] = 1; // error, read only
}
```

**TIP:** 当函数确实要修改数组元素值，才应该把形参设置为非常量的指针。

#### 数组引用形参 

形参可以是数组引用，此时数组大小成为数组类型的一部分，不会退化成指针。

```c++
void fun(int (&arr) [10]); // &arr 两端的括号不可少，因为下标操作符具有更高的优先级
```

`fun` 函数被限制只接受指定大小为 10 的数组。

#### 传递多维数组

多维数组实质上是数组的数组。当传递多维数组给函数时，实际上传递是一个指向数组的指针。数组的第二维的大小是数组类型一部分，不可忽略。

```c++
// m 指向数组的首元素，该数组的元素是由 10 个整数构成的数组
void fun(int (*m)[10]); // 包裹 *m 的括号同样不可忽略
```

### 可变形参

TODO

### 返回值

`void` 函数可以没有 `return` 语句，也可以使用 `return;` 结束函数。

>当需要提前结束函数时，可以使用 `return` 语句。

`void` 函数可以 `return` 另外一个 `void` 函数。

如果有返回值的函数结束时没有提供 `return` 语句，则行为是 **未定义** 的。

**注意：** 不要返回局部变量的指针或引用，因为函数结束会释放局部变量。

### 引用返回左值

调用一个返回引用的函数得到左值，否则得到右值。

返回左值的函数可以出现在等式左边。

```cpp
char &fun();
fun() = 'a'; // 合法
```

### 列表初始化返回值

C++11 规定，函数可以返回花括号包围的列表。

```cpp
vector<string> process()
{
	if(...)
		return {};
	else if(....)
		return {"a","b"};
	else 
		return {"a","b","c"};
}
```

如果返回的是内置类型，则花括号最多包裹一个值，且该值所占空间不大于目标类型的空间；

如果返回的是类类型，则由类决定初始值(花括号里的列表)如何使用。

### main 函数可以没有 `return` 语句

### 数组作为返回值

#### 返回数组指针

函数可以返回数组的指针或引用。使用 **类型别名** 可以简化做法。

```cpp
typedef int arrT[10]; // arrT类型 表示长度为 10 的数组
using arrT = int[10]; // 上面的等价声明
arrT* func(int i);    // 返回一个指向含有 10 个整数的数组的指针
```

返回数组指针的函数形式如下：

```cpp
Type (* function(params_list)) [dimension]
```

#### 使用尾置返回类型

C++11 规定可以使用 **尾置返回类型(trailing return type)**，简化复杂返回值的函数。

```cpp
// 函数返回一个指针，该指针指向长度为10的整数数组
auto fun(int i) -> int(*)[10];
```

#### `decltype`

`decltype` 可以让你获得编译期就能知道的类型。

```cpp
int odd[] = {2,4,6,8};
int even[] = {1,3,5,7};
decltype(even) *fun(int i)
{
	return (i % 2) ? &odd : &even;
}
```
### 函数重载

同一作用域内，几个函数名字相同，形参列表不同，称之为 **重载(overloaded)**。

#### 重载和 const 形参

顶层 `const` 不影响传入函数的对象。所以，一个拥有顶层 `const` 的形参无法与另一个没有顶层 `const` 形参区分开来。

```cpp
// 二者雷同
void fun(const int);
void fun(int);
```

但是如果形参是某个类型的指针或引用，则可以区分指向是常量对象还是非常量对象来实现函数重载。此时，`const` 是底层的。

```cpp
// 二者不同
void fun(const int*);
void fun(int*);
// 二者不同
void fun(const int&);
void fun(int&);
```

因为 `const` 不能转换为其他类型，所以只能把 `const` 对象传递给 `const` 形参。而非常量可以转换成 `const`，所以上面的四个函数也可以作用于非常量对象或指向非常量对象的指针。

#### `const_cast` 和重载

`const_cast` 可用于函数重载。

```cpp
const string &shorterString(const string& s1, const string& s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}
string &shorterString(string &s1, string &s2)
{
	auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
	return const_cast<string&>(r);
}
```

第二个版本里，先将实参强制转换成对 `const` 的引用，然后调用 `const` 版本的函数。

### 特殊用途语言特性

#### 默认实参

函数调用时，只能省略尾部的参数。实参按照位置解析，默认实参负责填补函数调用缺少的尾部实参。

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，就可以作为默认实参。

用作默认实参的名字在函数声明所在的定义域内解析，而求值过程发生在函数调用。

#### 内联函数和 `constexpr` 函数

将函数指定为内联函数，通常就是将它在每个调用点上 **内联地** 展开。内联函数可以避免函数调用的开销。

定义为内联函数是对编译器的请求，编译器不一定执行。

一般来说，内联用于优化规模小、调用频繁的函数。很多编译器不支持内联递归函数。

`constexpr` 函数是指能用于常量表达式的函数。定义时遵循几项约定：函数的返回值和形参的类型都是字面值类型，而且只能有一条 `return` 语句。

`constexpr` 函数被隐式地指定为内联函数。`constexpr` 函数不一定返回常量表达式。


#### 调试

`assert` 是一种 **预处理宏**，使用一个表达式作为它的条件:

```cpp
#include <cassert>
assert(expr);
```

如果表达式为假，则输出信息并终止程序的执行，否则什么也不做。常用于检查 “不可能” 的情况。

如果定义了 `NDEBUG`，则 `assert` 什么也不做。可以使用 `#define` 语句定义，也可以通过命令行选项关闭。

```shell
$ CC -D NDEBUG main.c
```

在调试过程中，可以通过 `__func__` 打印当前调试的函数的名字。除了这些，还有

* `__FILE__` 存放文件名的字符串字面量。
* `__LINE__` 存放当前行号的整形字面量。
* `__TIME__` 编译时间的字符串字面量。
* `__DATE__` 编译日期的字符串字面量。
