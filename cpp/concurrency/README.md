# C++ 并发

## 线程管理

每个程序至少有一个线程：执行 `main()` 函数的线程，其余线程有其各自的入口函数。

在为一个线程创建了一个 `std::thread` 对象后，需要等待这个线程结束；不过，线程需要先进行启动。

使用 C++ 线程库启动线程，可以归结为构造 std::thread` 对象：

```cpp
void do_some_work();
std::thread my_thread(do_some_work);
```

为了让编译器识别 `std::thread` 类，要包含 `<thread>` 头文件。`std::thread` 也可以用可调用类型构造。

启动线程后，需要明确是要等待线程结束，还是让其自主运行。如果 `std::thread` 对象销毁之前还没有做出决定，程序就会终止( `std::thread` 的析构函数会调用 `std::terminate()`)。

如果不等待线程，就必须保证线程结束之前，可访问的数据的 **有效性**。

这种情况很可能发生在线程还没结束，函数已经退出的时候，这时线程函数还持有函数局部变量的指针或引用。

如果需要等待线程，相关的 `std::thread` 实例需要使用 `join()`。

调用 `join()` 的行为，还清理了线程相关的存储部分，这样`std::thread` 对象将不再与已经完成的线程有任何关联。这意味着，一旦已经使用过 `join()`，`std::thread` 对象就不能再次加入了，当对其使用 `joinable()` 时，将返回 `false`。

使用 `detach()` 会让线程在后台运行，这就意味着主线程不能与之产生直接交互。

## 线程同步

### 互斥量

C++ 中通过实例化 `std::mutex` 创建互斥量实例，通过成员函数 `lock()` 对互斥量上锁，`unlock()` 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 `unlock()`，也包括异常的情况。C++ 标准库为互斥量提供了一个 RAII 语法的模板类 `std::lock_guard`，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。


