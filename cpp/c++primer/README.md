# C++ Primer 笔记

## 函数

### 数组作为参数

数组有两个特殊的性质：

1. 不允许拷贝数组
2. 数组使用时会将其转换为指针


当我们为一个函数传递数组时，实际上传递的是指向数组首元素的指针。

```c++
void print(const int*)
void print(const int[]);
void print(const int[10]);
```

这三个函数是等价的：形参都是 `const int *`。

#### 常见传递数组参数有三种方式：

##### 使用标记指定数组长度

典型代表是 C 风格字符串。

##### 使用标准库规范

传递指向数组 **首元素** 和 **尾后元素** 的指针。

##### 显式传递一个表示数组大小的形参

#### 数组形参与 `const`

为数组参数添加 `const` 后不能在函数里修改数组元素值

```c++
void fun(const int * a)
{
	a[0] = 1; // error, read only
}
```

**TIP:** 当函数确实要修改数组元素值，才应该把形参设置为非常量的指针。

#### 数组引用形参 

形参可以是数组引用，此时数组大小成为数组类型的一部分，不会退化成指针。

```c++
void fun(int (&arr) [10]); // &arr 两端的括号不可少，因为下标操作符具有更高的优先级
```

`fun` 函数被限制只接受指定大小为 10 的数组。

#### 传递多维数组

多维数组实质上是数组的数组。当传递多维数组给函数时，实际上传递是一个指向数组的指针。数组的第二维的大小是数组类型一部分，不可忽略。

```c++
// m 指向数组的首元素，该数组的元素是由 10 个整数构成的数组
void fun(int (*m)[10]); // 包裹 *m 的括号同样不可忽略
```

### 可变形参

TODO

### 返回值

`void` 函数可以没有 `return` 语句，也可以使用 `return;` 结束函数。

>当需要提前结束函数时，可以使用 `return` 语句。

`void` 函数可以 `return` 另外一个 `void` 函数。

如果有返回值的函数结束时没有提供 `return` 语句，则行为是 **未定义** 的。

**注意：** 不要返回局部变量的指针或引用，因为函数结束会释放局部变量。

### 引用返回左值

调用一个返回引用的函数得到左值，否则得到右值。

返回左值的函数可以出现在等式左边。

```cpp
char &fun();
fun() = 'a'; // 合法
```

### 列表初始化返回值

C++11 规定，函数可以返回花括号包围的列表。

```cpp
vector<string> process()
{
	if(...)
		return {};
	else if(....)
		return {"a","b"};
	else 
		return {"a","b","c"};
}
```

如果返回的是内置类型，则花括号最多包裹一个值，且该值所占空间不大于目标类型的空间；

如果返回的是类类型，则由类决定初始值(花括号里的列表)如何使用。

### main 函数可以没有 `return` 语句

### 数组作为返回值

#### 返回数组指针

函数可以返回数组的指针或引用。使用 **类型别名** 可以简化做法。

```cpp
typedef int arrT[10]; // arrT类型 表示长度为 10 的数组
using arrT = int[10]; // 上面的等价声明
arrT* func(int i);    // 返回一个指向含有 10 个整数的数组的指针
```

返回数组指针的函数形式如下：

```cpp
Type (* function(params_list)) [dimension]
```

#### 使用尾置返回类型

C++11 规定可以使用 **尾置返回类型(trailing return type)**，简化复杂返回值的函数。

```cpp
// 函数返回一个指针，该指针指向长度为10的整数数组
auto fun(int i) -> int(*)[10];
```

#### `decltype`

`decltype` 可以让你获得编译期就能知道的类型。

```cpp
int odd[] = {2,4,6,8};
int even[] = {1,3,5,7};
decltype(even) *fun(int i)
{
	return (i % 2) ? &odd : &even;
}
```
### 函数重载

同一作用域内，几个函数名字相同，形参列表不同，称之为 **重载(overloaded)**。

#### 重载和 const 形参

顶层 `const` 不影响传入函数的对象。所以，一个拥有顶层 `const` 的形参无法与另一个没有顶层 `const` 形参区分开来。

```cpp
// 二者雷同
void fun(const int);
void fun(int);
```

但是如果形参是某个类型的指针或引用，则可以区分指向是常量对象还是非常量对象来实现函数重载。此时，`const` 是底层的。

```cpp
// 二者不同
void fun(const int*);
void fun(int*);
// 二者不同
void fun(const int&);
void fun(int&);
```

因为 `const` 不能转换为其他类型，所以只能把 `const` 对象传递给 `const` 形参。而非常量可以转换成 `const`，所以上面的四个函数也可以作用于非常量对象或指向非常量对象的指针。

#### `const_cast` 和重载

`const_cast` 可用于函数重载。

```cpp
const string &shorterString(const string& s1, const string& s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}
string &shorterString(string &s1, string &s2)
{
	auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
	return const_cast<string&>(r);
}
```

第二个版本里，先将实参强制转换成对 `const` 的引用，然后调用 `const` 版本的函数。

### 特殊用途语言特性

#### 默认实参

函数调用时，只能省略尾部的参数。实参按照位置解析，默认实参负责填补函数调用缺少的尾部实参。

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，就可以作为默认实参。

用作默认实参的名字在函数声明所在的定义域内解析，而求值过程发生在函数调用。

#### 内联函数和 `constexpr` 函数

将函数指定为内联函数，通常就是将它在每个调用点上 **内联地** 展开。内联函数可以避免函数调用的开销。

定义为内联函数是对编译器的请求，编译器不一定执行。

一般来说，内联用于优化规模小、调用频繁的函数。很多编译器不支持内联递归函数。

`constexpr` 函数是指能用于常量表达式的函数。定义时遵循几项约定：函数的返回值和形参的类型都是字面值类型，而且只能有一条 `return` 语句。

`constexpr` 函数被隐式地指定为内联函数。`constexpr` 函数不一定返回常量表达式。


#### 调试

`assert` 是一种 **预处理宏**，使用一个表达式作为它的条件:

```cpp
#include <cassert>
assert(expr);
```

如果表达式为假，则输出信息并终止程序的执行，否则什么也不做。常用于检查 “不可能” 的情况。

如果定义了 `NDEBUG`，则 `assert` 什么也不做。可以使用 `#define` 语句定义，也可以通过命令行选项关闭。

```shell
$ CC -D NDEBUG main.c
```

在调试过程中，可以通过 `__func__` 打印当前调试的函数的名字。除了这些，还有

* `__FILE__` 存放文件名的字符串字面量。
* `__LINE__` 存放当前行号的整形字面量。
* `__TIME__` 编译时间的字符串字面量。
* `__DATE__` 编译日期的字符串字面量。

### 函数匹配

函数匹配的第一步先确定 **候选函数**，候选函数要与被调用的函数同名，且申明在调用时可见。

第二步考察实参和形参，选出能匹配的函数，称之为 **可行函数**。要求实参与可行函数的形参类型相同或实参能转换为形参。

第三步，选出最佳匹配，基本原则是 **实参类型与形参类型越接近越好**。

#### 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分了几个等级。

1. 精确匹配
   * 完全相同
   * 实参从指针类型或函数类型转换成对应的指针类型
   * 向实参添加顶层 `const` 或 移除顶层 `const`

2. 通过 `const` 类型转换实现的匹配

3. 通过类型提升实现的匹配

4. 通过算术类型转换或指针转换

5. 通过类类型转换实现的匹配

### 函数指针

函数指针指向 **函数**，而非对象。而函数类型又返回值和形参类型决定。

当我们把函数当做一个值使用时，自动转换为指针。

## 类

类的基本思想是 **数据抽象** 和 **封装**。

C++ 中的类由成员数据和成员函数组成。成员变量和成员函数都得在类内部声明，但成员变量可以在类外部定义。

成员函数通过 `this` 隐式访问调用它的对象。当对象调用成员函数时，用对象地址初始化 `this`。

### 构造函数

类通过构造函数定义了对象的初始化方式。如果没有显式声明构造函数，编译器会自动生成一个默认的构造函数，其初始化规则是，
* 有类内初始值，则用来初始化。
* 否则，默认初始化。

`= default;` 表示该构造函数为默认构造函数。

除了定义类的对象如何被初始化，也需定义赋值、拷贝对象的操作。


## IO 库

## 顺序容器

顺序容器定义了控制元素存储和访问顺序的能力。这种顺序仅有元素加入容器的顺序决定，和元素的值无关。

* `vector`，可变数组，支持快速随机访问，在尾部之外插入元素可能很慢。

* `deque`，双端队列。

* `list`，双向链表。

* `forward_list`，单向链表。

* `array`，固定长度的数组。

* `string`，和 `vector` 类型，但仅用来保存字符。

## 泛型算法

### 参数绑定

```cpp
#include<functional>
auto newCallable = bind(callable, arg_list);
```

接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。

`bind` 不仅可以给函数绑定参数，也可以改变已有参数的顺序。

## 动态内存

### 智能指针

* `share_ptr` 允许多个指针指向同一个对象。

* `unique_ptr` 独占所指对象。

* `weak_ptr` 不管理指向的对象。

#### `share_ptr`

`share_ptr` 使用引用计数管理资源。

```cpp
// 空智能指针
share_ptr<T> sp;

// 返回一个 share_ptr
make_share<T>(args);

// 拷贝一个 share_ptr，递增引用计数
share_ptr<T> p(q);

// 返回p中保存的指针
p.get()

// 交换指针
swap(p,q);
p.swap(q);

// 递减 p 的引用计数，递减 q 的引用计数
p = q;

// 判断引用数为 1
p.unique();

// 返回引用计数
p.use_count();
```

#### `unique_ptr`

当定义一个 `unique_ptr` 时，需要绑定到一个 `new` 返回的指针。

```cpp
// 空指针
unique_ptr<T> u;

// 使用一个类型为 D 的可调用对象释放指针
// 默认使用 delete 释放
unique_ptr<T, D> u;

// 使用类型为D的对象d来释放指针
unique_ptr<T, D> u(d); 

//释放
u = nullptr;

// 放弃控制权，返回指针，置空 u
u.release();

// 释放所指对象
u.reset();

// 释放所指对象，并指向一个新的指针
u.reset(q);
```

`unique_ptr` 不支持拷贝或赋值。

#### `weak_ptr`

